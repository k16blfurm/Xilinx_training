--<insert: c:\HW\releasedULD\headers\DAC_SPI.head>
-- -----------------------------------------------------------------------------
--
-- module:    DAC_SPI
-- project:   wave_gen
-- company:   Xilinx, Inc.
-- author:    WK, AW
-- 
-- comment:
--   This module takes each sample generated by the sample generator  and
--   sends it to the digital to analog converter (DAC) using the  SPI
--   protocol. Each SPI cycle is 32 clocks long, consisting of an  address,
--   command, and 16 bits of data (MSbit first). The DAC on the  development
--   boards use only the most significant 12 out of the 16 bit samples,  but
--   all 16 bits are transmitted.
-- 
-- known issues:
-- status           id     found     description                      by fixed date  by    comment
-- 
-- version history:
--   version    date    author     description
--    11.1-001 20 APR 2009 WK       New for version 11.1            
-- 
-- -----------------------------------------------------------------------
-- 
-- 
--<copyright-disclaimer-start>
--<copyright-disclaimer-start>
--  **************************************************************************************************************
--  * © 2023 Advanced Micro Devices, Inc. All rights reserved.                                                   *
--  * DISCLAIMER                                                                                                 *
--  * The information contained herein is for informational purposes only, and is subject to change              *
--  * without notice. While every precaution has been taken in the preparation of this document, it              *
--  * may contain technical inaccuracies, omissions and typographical errors, and AMD is under no                *
--  * obligation to update or otherwise correct this information.  Advanced Micro Devices, Inc. makes            *
--  * no representations or warranties with respect to the accuracy or completeness of the contents of           *
--  * this document, and assumes no liability of any kind, including the implied warranties of noninfringement,  *
--  * merchantability or fitness for particular purposes, with respect to the operation or use of AMD            *
--  * hardware, software or other products described herein.  No license, including implied or                   *
--  * arising by estoppel, to any intellectual property rights is granted by this document.  Terms and           *
--  * limitations applicable to the purchase or use of AMD’s products are as set forth in a signed agreement     *
--  * between the parties or in AMD's Standard Terms and Conditions of Sale. GD-18                               *
--  *                                                                                                            *
--  **************************************************************************************************************
--<copyright-disclaimer-end>
--<copyright-disclaimer-end>
--
-- -----------------------------------------------------------------------
--

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.NUMERIC_STD.ALL;

library work;
use work.wave_gen_pkg.all;


entity DAC_SPI is
    Port (clk_tx         : in  std_logic;                    -- transmitter clock
          rst_clk_tx     : in  std_logic;                    -- reset signal synchronized to clk_tx
          en_clk_samp    : in  std_logic;                    -- indication that the next rising edge of clk_tx will coincide with the rising edge of clk_smap
          samp           : in  std_logic_vector(15 downto 0);-- the current sample being output. Only valid when samp_val is asserted
          samp_val       : in  std_logic;                    -- a vaild sample is being output. Asserted for one clk_samp period for each sample
          SPI_ss_b_o     : out std_logic;                    -- SPI serial flash chip select - tied to 1 (disabled)
          spi_clk_o      : out std_logic;                    -- SPI clock
          spi_mosi_o     : out std_logic;                    -- SPI master-out-slave-in datum
          DAC_cs_n_o     : out std_logic;                    -- DAC SPI chip select (active low)
          DAC_clr_n_o    : out std_logic                     -- DAC clear (active low)
          );
end DAC_SPI;


architecture Behavioral of DAC_SPI is

       signal data_to_send     : std_logic_vector(31 downto 0) := (others=>'U');
       signal start_spi        : std_logic := 'U';
       signal active           : std_logic := 'U';
       signal old_active       : std_logic := 'U';
       signal old_old_active   : std_logic := 'U';
       signal stretched_active : std_logic := 'U';
       signal spi_mosi         : std_logic := 'U';
       signal dac_cs_n         : std_logic := 'U';

    begin
    
       -- Generate dac_clr_n - asserted only when internal reset is asserted
       DACrst: process (clk_tx)
          begin
             if rising_edge(clk_tx) then                  -- process occurs synchonously with the tx clock
                if (rst_clk_tx = '1') then                -- has the internal reset been asserted?
                   dac_clr_n_o <= '0';                    -- active low assertion of reset
                else                                      -- do non-reset activities
                   dac_clr_n_o <= '1';                    -- no reset applied
                end if;                                   -- end of reset/non-reset activities
             end if;                                      -- end of synchronous events
          end process DACrst;
          
       -- capture the sample to send  [Write to an Update (Power Up) ch, N + channel A]
        data_to_send <= X"0030" &  samp;                  -- The sample to send
       
       -- when the new sample is captured, start the spi transfer on the next clk_samp
       start_spi <= samp_val and en_clk_samp;
          
       -- generate the serialized outputs
       genSerOut: process (clk_tx)
             variable bit_cnt     : integer range 0 to 32 := 0;
          begin
             if rising_edge(clk_tx) then                  -- this process runs synchronously to the tx clock
                if (rst_clk_tx = '1') then                -- is there a reset in progress?
                   active         <= '0';
                   old_active     <= '0';
                   old_old_active <= '0';
                   bit_cnt        := 0;
                   dac_cs_n       <= '1';                 -- keep DAC unselected (active low signal)
                   spi_mosi       <= '1';                 -- line idle high                
                else                                      -- no reset, do "normal" events
                   old_active     <= active;              -- one clock to account for pipeline delay of output
                   old_old_active <= old_active;          -- hold the last value for an extra clock
                   if (active = '0') then                 -- if we're currently not active then
                      dac_cs_n    <= '1';                 -- DAC normally disabled
                      spi_mosi    <= '1';                 -- line normally idles high
                      if (start_spi = '1') then           -- has there been a request to start an SPI transfer?
                         active <= '1';                   -- set flag indicating that we're actively in SPI transfer
                         dac_cs_n   <= '0';               -- select the DAC (active low)
                         spi_mosi   <= data_to_send(31);  -- send the first bit of the sequence
                         bit_cnt    := 30;                -- 32 bits to send, but we just sent one
                      end if;                             -- end of start SPI request test
                   else                                   -- we are active
                      spi_mosi   <= data_to_send(bit_cnt);-- send the next bit
                      if (bit_cnt = 0) then               -- did we just send the last bit?
                         active <= '0';                   -- indicate to the other processes that we're done sending
                      else                                -- still in the process of sending
                         bit_cnt := bit_cnt - 1;          -- count the bit that was just sent
                      end if;                             -- end of bit count check
                   end if;                                -- end of active tests
                end if;                                   -- end reset test 
             end if;                                      -- end synchronous events
          end process genSerOut;     

       -- Pipeline the outputs to ensure the can be pushed into the IOBs
       pipeSerOut: process (clk_tx)
          begin
             if rising_edge(clk_tx) then                  -- this process runs synchronously to the tx clock
                if (rst_clk_tx = '1') then                -- is there a reset in progress?
                  spi_mosi_o     <= '0';
                  dac_cs_n_o     <= '1';
                else
                  spi_mosi_o     <= spi_mosi;
                  dac_cs_n_o     <= dac_cs_n;
                end if;
              end if;
            end process pipeSerOut;
    
      -- Generate the SPI clock using the DDR flop
      -- Use old_active due to the pipelining of the output data, and stretch it by 
      -- one clock using old_old_active
      stretched_active <= old_active or old_old_active;
      out_ddr_flop_spi_clk_i0: out_ddr_flop  
          port map(clk    => clk_tx,
                   rst    => '0',
                   d_rise => vcc(0),
                   d_fall => stretched_active,
                   q         => spi_clk_o);
                   
      SPI_ss_b_o    <= '1';

    end Behavioral;

